import { CanvasProcessor } from './CanvasProcessor.js';

export class WebpProcessor extends CanvasProcessor {
    constructor(file, ext) {
        super(file, ext, 'image/webp');
        this.engineName = 'ExifReader Scout + Canvas Purge';
        this.engineClass = 'text-blue-400 font-mono text-sm';
        this.buttonText = 'Execute Canvas Purge';
    }

    async parse() {
        let exifData = {};

        if (!window.ExifReader) {
            console.error("[WebpProcessor] window.ExifReader is missing. Check your HTML script tag!");
            const terminalOut = document.getElementById('terminal-out');
            if(terminalOut) terminalOut.innerHTML += `<div class="log-line"><span class="val-high">SYSTEM WARNING: ExifReader missing. Reading failed.</span></div>`;
            return null;
        }

        try {
            // THE FIX: We MUST await the promise. We pass the raw File object directly.
            // ExifReader is aggressive enough to ignore broken WebP headers automatically.
            const tags = await window.ExifReader.load(this.file);
            
            for (const [key, tag] of Object.entries(tags)) {
                // Skip internal structural tags generated by ExifReader
                if (['Image Width', 'Image Height', 'colorSpace'].includes(key)) continue;
                
                // ExifReader provides a human-readable 'description' or raw 'value'
                let val = tag.description !== undefined ? tag.description : tag.value;
                if (Array.isArray(val)) val = val.join(', ');

                exifData[key] = val;
            }

        } catch(e) {
            console.warn("[WebpProcessor] ExifReader failed to parse file.", e);
        }

        return Object.keys(exifData).length > 0 ? exifData : null;
    }

    // We do NOT need a scrub() method here. 
    // Because we extend CanvasProcessor, it automatically inherits the perfect Pixel-Matrix wipe.
}
